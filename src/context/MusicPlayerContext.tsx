"use client";

import React, {
  createContext,
  useContext,
  useState,
  useRef,
  useEffect,
  ReactNode,
} from "react";
import axios from "axios";
import { getAuthHeaders } from "@/services/authService";
import { addToFavorite, removeFromFavorite, checkIsFavorite, clearFavoriteStatusCache, favoriteEvents } from "@/services/favoriteService";

// --- B∆Ø·ªöC 1: ƒê·ªäNH NGHƒ®A C√ÅC KI·ªÇU D·ªÆ LI·ªÜU T·ª™ API ---

// Ki·ªÉu d·ªØ li·ªáu cho m·ªôt ngh·ªá sƒ© trong API
interface ApiArtist {
  id: number;
  name: string;
  picture: string;
  // ... c√°c tr∆∞·ªùng kh√°c n·∫øu c√≥
}

// Ki·ªÉu d·ªØ li·ªáu cho m·ªôt b√†i h√°t trong API (c·∫£ trong queue v√† detail)
interface ApiMusic {
  id: number;
  name: string;
  coverPhoto: string;
  resourceLink: string;
  favoriteCount: number;
  listenCount: number;
  lyric?: string;
  artists?: ApiArtist[];
  // ... c√°c tr∆∞·ªùng kh√°c t·ª´ API detail
}

// Ki·ªÉu d·ªØ li·ªáu cho m·ªôt item trong streamQueue
interface ApiQueueItem {
  music: ApiMusic;
}

// --- KI·ªÇU D·ªÆ LI·ªÜU N·ªòI B·ªò C·ª¶A PLAYER ---
// ƒê√¢y l√† d·ªØ li·ªáu ƒë√£ ƒë∆∞·ª£c chu·∫©n h√≥a ƒë·ªÉ UI s·ª≠ d·ª•ng
export interface GlobalMusic {
  id: string; // Lu√¥n l√† string ƒë·ªÉ nh·∫•t qu√°n
  name: string;
  artist: string;
  coverPhoto: string;
  resourceLink: string;
  favoriteCount: number;
  isFavorite?: boolean;
  // Th√™m c√°c tr∆∞·ªùng b·∫°n mu·ªën hi·ªÉn th·ªã chi ti·∫øt
  lyric?: string;
  fullApiData?: ApiMusic; // L∆∞u l·∫°i to√†n b·ªô d·ªØ li·ªáu g·ªëc t·ª´ API n·∫øu c·∫ßn
}

// --- STATE C·ª¶A CONTEXT ---
interface MusicPlayerState {
  playlist: GlobalMusic[];
  currentTrackIndex: number | null;
  currentMusic: GlobalMusic | null;
  isPlaying: boolean;
  currentTime: number;
  duration: number;
  isLoading: boolean; // TH√äM M·ªöI: Tr·∫°ng th√°i loading to√†n c·ª•c
  isExpanded: boolean;
  playSongById: (musicId: number | string) => Promise<void>; // THAY ƒê·ªîI
  togglePlayPause: () => void;
  playNext: () => Promise<void>;
  playPrevious: () => Promise<void>;
  toggleFavorite: (songId: string) => Promise<void>;
  seek: (time: number) => void;
  toggleExpandPlayer: () => void;
  volume: number;
  changeVolume: (newVolume: number) => void;

  // ... c√°c h√†m kh√°c n·∫øu c·∫ßn
}

const MusicPlayerContext = createContext<MusicPlayerState | undefined>(
  undefined
);

// --- B∆Ø·ªöC 2: T√ÅI C·∫§U TR√öC HO√ÄN TO√ÄN PROVIDER ---

export const MusicPlayerProvider = ({ children }: { children: ReactNode }) => {
  const [playlist, setPlaylist] = useState<GlobalMusic[]>([]);
  const [currentTrackIndex, setCurrentTrackIndex] = useState<number | null>(
    null
  );
  const [volume, setVolume] = useState(1);
  const [isPlaying, setIsPlaying] = useState<boolean>(false);
  const [currentTime, setCurrentTime] = useState(0);
  const [duration, setDuration] = useState(0);
  const [isExpanded, setIsExpanded] = useState<boolean>(false);
  const [isLoading, setIsLoading] = useState<boolean>(false); // State loading m·ªõi
  const [audioSrc, setAudioSrc] = useState<string | null>(null);
  const [error, setError] = useState<string>("");

  const audioRef = useRef<HTMLAudioElement>(null);

  console.log("Current Track Index:", currentTrackIndex);
  console.log("Playlist:", playlist);

  const currentMusic =
    currentTrackIndex !== null ? playlist[currentTrackIndex] : null;

  // H√†m chuy·ªÉn ƒë·ªïi d·ªØ li·ªáu t·ª´ API Queue sang ƒë·ªãnh d·∫°ng GlobalMusic
  const mapApiQueueToGlobalMusic = (
    apiQueue: ApiQueueItem[]
  ): GlobalMusic[] => {
    console.log("Api Queue:", apiQueue);

    return apiQueue
      .filter(
        (item) =>
          item && // ƒê·∫£m b·∫£o 'item' kh√¥ng ph·∫£i l√† null/undefined
          item.music && // ƒê·∫£m b·∫£o 'item.music' kh√¥ng ph·∫£i l√† null/undefined <--- ƒêI·ªÄU KI·ªÜN C·ª¶A B·∫†N ƒê√É C√ì ·ªû ƒê√ÇY
          typeof item.music.id === "number" && // ƒê·∫£m b·∫£o 'id' l√† s·ªë
          typeof item.music.name === "string" // ƒê·∫£m b·∫£o 'name' l√† chu·ªói
      )
      .map((item) => {
        // Ch·ªâ nh·ªØng item h·ª£p l·ªá m·ªõi v√†o ƒë∆∞·ª£c h√†m map n√†y
        const musicData = item.music; // L√∫c n√†y, musicData ch·∫Øc ch·∫Øn kh√¥ng ph·∫£i l√† null
        return {
          id: musicData.id.toString(),
          name: musicData.name,
          artist:
            musicData.artists && musicData.artists.length > 0
              ? musicData.artists[0].name
              : "Ngh·ªá sƒ© ch∆∞a x√°c ƒë·ªãnh",
          coverPhoto: musicData.coverPhoto || "/default-cover.png",
          resourceLink: musicData.resourceLink || "", // S·∫Ω ƒë∆∞·ª£c c·∫≠p nh·∫≠t sau khi g·ªçi API detail
          favoriteCount: musicData.favoriteCount || 0,
          isFavorite: false,
          lyric: musicData.lyric,
          fullApiData: musicData,
        };
      });
  };

  // H√†m ch√≠nh ƒëi·ªÅu ph·ªëi chu·ªói API
  const playSongById = async (musicId: number | string) => {
    setIsLoading(true);
    setError("");
    try {
      // 1. G·ªçi API Add to Queue
      const queueResponse = await axios.post(
        `https://api.sonata.io.vn/api/v1/stream-queue/add/${musicId}`,
        {},
        { headers: getAuthHeaders() }
      );

      if (!queueResponse.data.success)
        throw new Error("Kh√¥ng th·ªÉ th√™m v√†o h√†ng ch·ªù.");

      const { streamQueue, currentPlaying } = queueResponse.data.data;

      // 2. L·∫•y musicId hi·ªán t·∫°i v√† c·∫≠p nh·∫≠t playlist
      const currentPlayingId = currentPlaying.musicId;
      const newPlaylist = mapApiQueueToGlobalMusic(streamQueue);
      setPlaylist(newPlaylist);
      setCurrentTrackIndex(currentPlaying.index);

      // 3. G·ªçi API Get Music Detail
      const detailResponse = await axios.get(
        `https://api.sonata.io.vn/api/v1/music/${currentPlayingId}`,
        { headers: getAuthHeaders() }
      );

      if (!detailResponse.data.success)
        throw new Error("Kh√¥ng th·ªÉ l·∫•y chi ti·∫øt b√†i h√°t.");

      const detailedMusicData: ApiMusic = detailResponse.data.data;

      // 4. C·∫≠p nh·∫≠t b√†i h√°t hi·ªán t·∫°i trong playlist v·ªõi d·ªØ li·ªáu chi ti·∫øt
      setPlaylist((prevPlaylist) => {
        const updatedPlaylist = [...prevPlaylist];
        const trackIndex = currentPlaying.index;
        if (updatedPlaylist[trackIndex]) {
          updatedPlaylist[trackIndex] = {
            ...updatedPlaylist[trackIndex], // Gi·ªØ l·∫°i th√¥ng tin c∆° b·∫£n
            resourceLink: detailedMusicData.resourceLink, // C·∫≠p nh·∫≠t link nh·∫°c th·∫≠t
            lyric: detailedMusicData.lyric,
            fullApiData: detailedMusicData, // L∆∞u l·∫°i to√†n b·ªô data g·ªëc
          };
        }
        return updatedPlaylist;
      });

      // 5. Fetch v√† ph√°t audio t·ª´ `resourceLink` m·ªõi
      const audioBlobResponse = await axios.get(
        detailedMusicData.resourceLink,
        {
          headers: { ...getAuthHeaders() },
          responseType: "blob",
        }
      );
      const audioUrl = URL.createObjectURL(new Blob([audioBlobResponse.data]));

      if (audioSrc && audioSrc.startsWith("blob:")) {
        URL.revokeObjectURL(audioSrc);
      }
      setAudioSrc(audioUrl);
      setIsPlaying(true);

      console.log("ƒê√£ ph√°t b√†i h√°t:", detailedMusicData.name);
    } catch (err) {
      console.error("L·ªói khi ph√°t nh·∫°c:", err);
      setError("ƒê√£ c√≥ l·ªói x·∫£y ra khi ph√°t nh·∫°c.");
      // Reset state
      setPlaylist([]);
      setCurrentTrackIndex(null);
    } finally {
      setIsLoading(false);
    }
  };

  // H√†m next/previous gi·ªù ƒë√¢y s·∫Ω g·ªçi l·∫°i playSongById
  const playNext = async () => {
    if (currentTrackIndex === null || playlist.length === 0) return;
    const nextIndex = (currentTrackIndex + 1) % playlist.length;
    const nextSongId = playlist[nextIndex].id;
    await playSongById(nextSongId);
  };

  const playPrevious = async () => {
    if (currentTrackIndex === null || playlist.length === 0) return;
    const prevIndex =
      (currentTrackIndex - 1 + playlist.length) % playlist.length;
    const prevSongId = playlist[prevIndex].id;
    await playSongById(prevSongId);
  };

  // --- C√°c h√†m v√† useEffect c√≤n l·∫°i ---

  const togglePlayPause = () => {
    if (audioRef.current && audioRef.current.src) setIsPlaying(!isPlaying);
  };
  const seek = (time: number) => {
    if (audioRef.current) audioRef.current.currentTime = time;
  };
  const changeVolume = (newVolume: number) => {
    if (audioRef.current) audioRef.current.volume = newVolume;
    setVolume(newVolume);
  };
  const toggleExpandPlayer = () => setIsExpanded(!isExpanded);

  useEffect(() => {
    const audio = audioRef.current;
    if (!audio) return;
    if (isPlaying && audio.src) {
      audio.play().catch((e) => console.error("Play error:", e));
    } else {
      audio.pause();
    }
  }, [isPlaying, audioSrc]);

  const handleTimeUpdate = () => {
    if (audioRef.current) setCurrentTime(audioRef.current.currentTime);
  };
  const handleLoadedMetadata = () => {
    if (audioRef.current) setDuration(audioRef.current.duration);
  };

  const handleEnded = () => {
    playNext();
  };

  const toggleFavorite = async (songId: string) => {
    try {
      const musicId = parseInt(songId);
      if (isNaN(musicId)) {
        console.error('Invalid music ID:', songId);
        return;
      }

      // T√¨m b√†i h√°t trong playlist hi·ªán t·∫°i
      const currentSong = playlist.find(song => song.id === songId);
      if (!currentSong) {
        console.error('Song not found in playlist:', songId);
        return;
      }

      console.log(`üéµ Toggling favorite for song: ${currentSong.name} (ID: ${musicId})`);

      // Ki·ªÉm tra tr·∫°ng th√°i favorite hi·ªán t·∫°i
      const isFavorite = currentSong.isFavorite || false;

      if (isFavorite) {
        // X√≥a kh·ªèi favorite
        await removeFromFavorite(musicId);
        console.log('‚úÖ Removed from favorites');
        
        // Emit global event
        favoriteEvents.emit('favoriteStatusChanged', {
          type: 'music',
          id: musicId,
          action: 'removed',
          newStatus: false
        });
      } else {
        // Th√™m v√†o favorite
        await addToFavorite(musicId);
        console.log('‚úÖ Added to favorites');
        
        // Emit global event
        favoriteEvents.emit('favoriteStatusChanged', {
          type: 'music',
          id: musicId,
          action: 'added',
          newStatus: true
        });
      }

      // Clear cache ƒë·ªÉ force refresh status
      clearFavoriteStatusCache(musicId);

      // C·∫≠p nh·∫≠t state local
      setPlaylist((prevPlaylist) =>
        prevPlaylist.map((song) =>
          song.id === songId ? { ...song, isFavorite: !isFavorite } : song
        )
      );

    } catch (error) {
      console.error('‚ùå Error toggling favorite:', error);
      // Clear cache trong tr∆∞·ªùng h·ª£p l·ªói ƒë·ªÉ force refresh
      const musicId = parseInt(songId);
      if (!isNaN(musicId)) {
        clearFavoriteStatusCache(musicId);
      }
      // C√≥ th·ªÉ th√™m toast notification ·ªü ƒë√¢y n·∫øu c·∫ßn
    }
  };

  const value = {
    playlist,
    currentTrackIndex,
    currentMusic,
    isPlaying,
    currentTime,
    duration,
    isLoading,
    isExpanded,
    volume,
    playSongById,
    togglePlayPause,
    playNext,
    playPrevious,
    toggleFavorite,
    changeVolume,
    seek,
    toggleExpandPlayer,
  };

  return (
    <MusicPlayerContext.Provider value={value}>
      <audio
        ref={audioRef}
        src={audioSrc || undefined}
        onTimeUpdate={handleTimeUpdate}
        onLoadedMetadata={handleLoadedMetadata}
        onEnded={handleEnded}
        className="hidden"
      />
      {children}
    </MusicPlayerContext.Provider>
  );
};

export const useMusicPlayer = (): MusicPlayerState => {
  const context = useContext(MusicPlayerContext);
  if (context === undefined)
    throw new Error("useMusicPlayer must be used within a MusicPlayerProvider");
  return context;
};
